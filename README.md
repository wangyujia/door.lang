# door.lang
door-lang分布式对象操作语言: The Language Of Door ( Distributed Object Operating Routine )  
首字母刚好组成中文的“门”，意为为分布式组件之间提供连接的'门'。  
```
    DOOR:'分布式对象操作程序'，其实是一种通用思想，目的是使用消息方式把对对象的操作抽象起来：
                            +-----+
        [in]msg:... ------> | obj | ------> [out]msg:...(para list)
                            +-----+
    总体实现有三个板块: door-plat | door-lang | door-edge

        door-plat ......... 运行在边云端节点的平台程序，实际名称为: DCOP ( Distributed Component Object Platform )
        door-lang ......... 平台内部组件间分布式交互语言，名称就为: DOOR
        door-edge ......... 运行在边缘设备上的操作系统，实际名称为: DONE ( Distributed Object Network Edge )

```


## Language Purpose
door-lang是一种多范式编程语言，支持面向对象范式，也支持函数式编程，也是为了更好的把二者结合在一起。  
目的是实现一种动态粘合组件(组件内部为C/C++或其他语言等编译之后的native模块)的胶水语言（动态语言），同时语言具有灵活小巧的特性和范式，比如lambda、闭包等（可在函数上下文中直接引用内部变量，更加符合随时计算的表达方式），借鉴了js/salt等既是对象式又是函数式的语言。  
来源是由于door-plat(DCOP平台)在实现组件(对象)间交互时，使用异步消息机制，无论是别人操作对象，还是对象通知别人，都是通过消息传递：
```
    +-----+     [request msg]   +-----+                      +-----+
    |     | ------------------> |     |     [event msg]      |     |
    | ... |                     | obj | -------------------> | ... |
    |     | <------------------ |     |                      |     |
    +-----+    [response msg]   +-----+                      +-----+
```
而消息是由多个参数值的结构（序列化）组成：
```
    op-object-attribute: arg1 op value1, arg2 op value2, arg3 op value3, ... ;
    op-object-attribute: value1, value2, value3, ... ;
    op-object: value1, value2, value3, ... ;
    object: value1, value2, value3, ... ;
```
这里属性可以为空，参数也可以直接按顺序匹配值，也可以省略操作。  
可见，消息与函数调用时的参数很像，如果把消息看作是函数参数，那么对象本身就相当于是被调用的函数。  
（统一函数和对象的思想自然就形成了。）  
但是，即使在函数为第一主体地位的常用函数式语言(比如js)中，也是把对象和函数分开定义的，在定义对象时，由于对象的成员只能是按照结构体定义（key-value|list等内存形式的结构），对象整体无法用一个函数来进行替代（虚定义），所以不方便进行跨语言打桩。比如：
```
    function A() {
        var a = 1;
        var b = 'x';
        var f1 = function(x) {return a+x;};
        var f2 = function(y) {return b+y;};
        return {
            f1: f1,
            f2: f2
        };
    }
    var a = A();
    function B() {
        var a = 1;
        var b = 'x';
        this.f1 = function(x) {return a+x;};
        this.f2 = function(y) {return b+y;};
    }
    var b = new B();
```
无论是哪种方式，返回的都是一个外部可见的结构。这种结构在C/C++中很不好控制，必须显式使用js的API函数来添加成员。
salt语言正是利用语法糖来统一函数和对象的（o.a -> o(a)），但是如果直接将对象当作一个函数，那么会失去围绕对象及其属性的丰富的自定义操作。所以这里不使用语法糖，而是按照刚才消息中的操作，给对象及其参数都加上一个'操作'：
```
    obj += 5        ->  set-obj:+=5         ->  obj(.'', +=5)
    obj.attr += 5   ->  set-obj-attr:+=5    ->  obj(.'attr', +=5)
    obj.func(x,y)   ->  call-obj-func:x,y   ->  obj(.'func', x, y)
```
函数在实现时，可以使用特定的方法来获取某个参数前的操作符，不指定参数获取的是无参数操作符(可在对象前面的操作符），比如: ++o, o++, !o 。
```
    函数C() {                           // door准备省略函数关键字，直接使用(){}作为函数语法
        var a = 1;
        var b = 'x';
        return 函数(m, ...) {           // 这里直接返回另外一个函数作为对象，之间形成闭包引用
            判断(m) {
                f1: {a+...}
                f2: {b+...}
            }
        }
    }
    var c = C(); // 这里的c实际上是一个C返回的函数，它以闭包方式引用着C内部的变量。
```

对比js嵌入到C/C++中，由于对象在定义时不是函数上下文，不太适合使用C/C++的native代码作为扩展。  
修改后的范式就可以使用一个函数（包括语言侧和C/C++侧）来定义一个对象(包含了参数前的操作)，统一了函数和对象，又支持了操作符等扩展定义，而且也可以统一DCOP之前定义的命令行语法：
```
    set-object:arg1+=5,arg2*=10;  ->  set-object("arg1", +=5, "arg2", *=10);    // set是对对象的操作
    get-object:arg1+5 @arg2==10;  ->  get-object("arg1", +5, @"arg2", ==10);    // get是对对象的操作，'@'之后的参数都是条件
    c.f1(100)  ->  c(."f1", 100)  ->  c:.f1,100
    c.m1 += 2  ->  c(."m1", +=2)  ->  c:.m1,+=2
```
（虽然显得有些怪异，可以看作用函数参数来序列化语义结构，呵呵，找个理由要说通啊）  
动态，是把类型/对象/函数/参数等信息动态化 ……  
另外，可支持编译为虚拟化的指令(bytescode字节码)或者本地机器码，字节码由VM解释执行（可加入AOT/JIT）……  


## Language Features
为了更好的支持动态更新指令(bytescode字节码)的片段，需要把函数定义得更为小巧和灵活，所以预备以块为单位（类似于一般语言的lambda或者oc的block）。块就等同于函数体，同时不同参数的变体可以相似变形为：type、function、object。
```
/// ----------------------------------------------
/// door语言: {} -> type | function | object
    A {}                    ->      {__type__:"type",__name__:"A",__attr__:{}}
    A () {}                 ->      {__type__:"function", __name:"A",__proc__:{}}
    var a = {}              ->      {__type__:"object"}
    var a = () {}           ->      {__type__:"function", __proc__:{}}
    var a = new A();        ->      {__type__:"A"}.A();
    var b = new a();        ->      {__type__:"A"}.A();
    var c = a.m;            ->      ('m' in a)? (a.m) : (a(m));
    a.m = 1;                ->      ('m' in a)? (a.m = 1) : (a(m, 1));
/// ----------------------------------------------


/// ----------------------------------------------
/// [类型] 用于描述对象的组成：(类似c++/java中的类的定义方式)
    A {
        static a = 100;             // 定义类型的静态变量
        static b = 'ABC';
        number a;                   // 属性名称: "类型名称/函数名称/对象名称"作为限定
        string b;
        c {
            m1 = true;              // 也可以直接用"[],{},或者直接赋初值"
        }
        const d = 123;
        __init__(n) {               // __init__用来声明构造函数
            this.a = n;             // this代表创建的对象
            this.b = 'abc';
        }
    }                       ->      {__type__:"type",__name__:"A",__attr__:{a:"number",b:"string",c:"object","c.m1":"bool"}}
/// [类型 - 创建对象] 用new来创建对象：(无论写不写参数，如果类型定义了__init__函数，则尽量调用该函数)
    var a = new A;          ->      {__type__:"A",a:null,b:‘abc'}
    var a = new A(1);       ->      {__type__:"A",a:1,b:'abc'}
/// [类型 - 静态变量] 定义类型静态变量必须定义在__static__里面
/// ----------------------------------------------
/// [函数 - 普通] 用于实现普通功能：
/// A() {
        printlog('abc');
    }
/// [函数 - 设置对象] 使用this设置对象成员：
    A() {
        this.a = 1;
        this.b = 'abc';
    }
/// [函数 - 成员函数] 使用this设置对象成员：
    {
        f1() {
            this.a = 1;
            this.b = 'abc';
        },
        f2: () {
            this.a = 2;
            this.b = 'efg';
        }
    }
/// [函数 - 创建对象] 用new来创建对象：(这里必须携带参数)
    var a = new A();
/// ----------------------------------------------
/// [对象] 除了使用new来创建对象外，还可以：
```


1）如何把类的信息动态化
    首先给类唯一名称，然后同创建类的创建函数关联起来。
    框架：使用工厂管理[类唯一名称:类创建函数]
    语言：所有一切既是对象又是函数
        一个对象能被调用，如果实现了__proc__成员函数，则调用该函数
        [函数形式定义的对象] 默认有__proc__成员函数：
            A() {...}   <==>   var A = {__name__:"A",__proc___:(){...}}
            
        如果对象没有实现__proc__，那么调用就是获取或者设置成员函数：
            A = {m:...}
            var a = A()

```
    A {
        __attr__: [
            a, b, get c, set d
        ],
        __init__: (n) {
            a = n;
            b = 'abc';
            get c = () {
                b + '[' + a + ']';
            };
        },
        __proc___: (m) {
            
        }
    }
    B(n) : A {
        this.a = n;
    }
    C(m, n) {
        this.b = m;
    }
    var a = A();
    var b = B();
    var c = C();
```


2) 如何创建对象
    
    相当于：
```
    A = {
        __func__ : (m ,n) {...},
        __attr__ : {
            a : number,
            b : string,
            c : function
        }
    }
```
    A是一个函数，使用this添加属性，this代表调用函数后构造的对象
    var a = A();

3) 如何表达类和对象
    类只是预置模型、初次结构的表达
    还说维持通用化的理论：万物皆对象
    但是外部只能看到对象的提供的服务(接口)

4) 如何表达对象的操作
    还是统一为发消息：外部解析服务后，服务接口组装消息并发送给对象，对象作为消息处理的实体而存在

