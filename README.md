# door.lang
DOOR(分布式对象操作)语言：The Language Of Door (Distributed Object Operating Routine)  
首字母刚好组成中文的“门”，意为为分布式组件之间提供连接的“门”。  


## Language Purpose
door-lang是一种多范式编程语言，支持面向对象范式，也支持函数式编程，也是为了更好的把二者结合在一起。  
目的是实现一种动态粘合组件(组件内部为C/C++等编译之后的native代码)的胶水语言（动态语言），同时语言具有灵活小巧的特性和范式，比如lambda、闭包等（可在函数上下文中直接引用内部变量），比如js。  
来源是由于DCOP平台在实现组件(对象)间交互时，使用异步消息机制，无论是别人操作对象，还是对象通知别人，都是通过消息传递：
```
    +-----+    [request msg]    +-----+     [notify msg]     +-----+
    | obj | ------------------> | obj | -------------------> | obj |
    +--^--+                     +-----+                      +-----+
       |                           |
       +---------------------------+
              [response msg]
```
而消息是由多个key-value序列化的结构组成：
```
    msg: {key1:value1,key2:value2,key3:value3}
```
消息与函数调用时的参数很像，如果把消息看作是函数参数，那么对象本身就相当于是被调用的函数。
（统一函数和对象的思想来源于另外一种salt语言，但是实际也是分布式消息自然而然就形成的。）
但是，即使在函数为第一主体地位的常用函数式语言中，也是把对象和函数分开定义的，在定义对象时，由于对象的成员只能是按照结构体定义（key-value|list等内存形式的结构），对象整体无法用一个函数来进行替代（虚定义），所以不方便进行跨语言定义对象。比如：
```
    function A() {
        var a = 1;
        var b = 'x';
        var f1 = function(x) {return a+x;};
        var f2 = function(y) {return b+y;};
        return {
            f1: f1,
            f2: f2
        };
    }
    var a = A();
    function B() {
        var a = 1;
        var b = 'x';
        this.f1 = function(x) {return a+x;};
        this.f2 = function(y) {return b+y;};
    }
    var b = new B();
```
无论是哪种方式，返回的都是一个外部可见的结构。这种结构在C/C++中很不好控制，必须显式使用js的API函数来添加成员。
salt语言正是利用语法糖来统一函数和对象的（o.a -> o(a)），但是又如何利用对象丰富的可操作定义呢，所以这里不使用语法糖，而是顺序展开对象调用参数：
```
    o += 5      -> o(+=5)
    o.a += 5    -> o(.a, +=5)
    o.f(x, y)   -> o(.f, x, y)
```
在每个函数参数前面增加一个参数的操作符，这种操作符在发送消息时是最为常用的：
```
    command:arg1=5,arg2+=3,arg3=arg1*arg2   -> command(arg1, =5, arg2, +=3, arg3, =(arg1*arg2))
```
函数在实现时，可以使用特定的方法来获取某个参数前的操作符，不指定参数获取的是无参数操作符(可在对象前面的操作符），比如: ++o, o++, !o 。
```
    函数C() {                           // door准备省略函数关键字，直接使用(){}作为函数语法
        var a = 1;
        var b = 'x';
        return 函数(m, ...) {           // 这里直接返回另外一个函数作为对象，之间形成闭包引用
            判断(:m) {
                .f1: {a+...}
                .f2: {b+...}
            }
        }
    }
    var c = C(); // 这里的c实际上是一个C返回的函数，它以闭包方式引用着C内部的变量。
    c.f1(100)   -> c(".f1", 100)    -> c:.f1,100
    c.m1 += 2   -> c(."m1", +=2)    -> c:.m1,+=2
```

对比js嵌入到C/C++中，由于对象在定义时不是函数上下文，不太适合使用C/C++的native代码作为扩展。  
修改后的范式就可以使用本地函数（包括语言侧和C/C++侧）来定义一个对象(包含了参数前的操作)，就像salt一样统一了函数和对象，又支持了操作符等扩展定义，更加支持虚函数行为来定义对象的动态语言（getter/setter/handler)，甚至是这样的命令行语法：
```
    set-object:arg1+=5,arg2*=10; -> object("arg1", += 5, "arg2", *= 10);
    get-object:arg1+5@arg2==100; -> 
```

同时，把类型/对象/函数/参数等信息动态化 ……
另外，可支持编译为虚拟化的指令(bytescode字节码)或者本地机器码，字节码由VM解释执行（可加入AOT/JIT）……


## Language Features
为了更好的支持动态更新指令(bytescode字节码)的片段，需要把函数定义得更为小巧和灵活，所以预备以块为单位（类似于一般语言的lambda或者oc的block）。块就等同于函数体，同时不同参数的变体可以相似变形为：type、function、object。
```
/// ----------------------------------------------
/// door语言: {} -> type | function | object
    A {}                    ->      {__type__:"type",__name__:"A",__attr__:{}}
    A () {}                 ->      {__type__:"function", __name:"A",__proc__:{}}
    var a = {}              ->      {__type__:"object"}
    var a = () {}           ->      {__type__:"function", __proc__:{}}
    var a = new A();        ->      {__type__:"A"}.A();
    var b = new a();        ->      {__type__:"A"}.A();
    var c = a.m;            ->      ('m' in a)? (a.m) : (a(m));
    a.m = 1;                ->      ('m' in a)? (a.m = 1) : (a(m, 1));
/// ----------------------------------------------


/// ----------------------------------------------
/// [类型] 用于描述对象的组成：(类似c++/java中的类的定义方式)
    A {
        static a = 100;             // 定义类型的静态变量
        static b = 'ABC';
        number a;                   // 属性名称: "类型名称/函数名称/对象名称"作为限定
        string b;
        c {
            m1 = true;              // 也可以直接用"[],{},或者直接赋初值"
        }
        const d = 123;
        __init__(n) {               // __init__用来声明构造函数
            this.a = n;             // this代表创建的对象
            this.b = 'abc';
        }
    }                       ->      {__type__:"type",__name__:"A",__attr__:{a:"number",b:"string",c:"object","c.m1":"bool"}}
/// [类型 - 创建对象] 用new来创建对象：(无论写不写参数，如果类型定义了__init__函数，则尽量调用该函数)
    var a = new A;          ->      {__type__:"A",a:null,b:‘abc'}
    var a = new A(1);       ->      {__type__:"A",a:1,b:'abc'}
/// [类型 - 静态变量] 定义类型静态变量必须定义在__static__里面
/// ----------------------------------------------
/// [函数 - 普通] 用于实现普通功能：
/// A() {
        printlog('abc');
    }
/// [函数 - 设置对象] 使用this设置对象成员：
    A() {
        this.a = 1;
        this.b = 'abc';
    }
/// [函数 - 成员函数] 使用this设置对象成员：
    {
        f1() {
            this.a = 1;
            this.b = 'abc';
        },
        f2: () {
            this.a = 2;
            this.b = 'efg';
        }
    }
/// [函数 - 创建对象] 用new来创建对象：(这里必须携带参数)
    var a = new A();
/// ----------------------------------------------
/// [对象] 除了使用new来创建对象外，还可以：
```


1）如何把类的信息动态化
    首先给类唯一名称，然后同创建类的创建函数关联起来。
    框架：使用工厂管理[类唯一名称:类创建函数]
    语言：所有一切既是对象又是函数
        一个对象能被调用，如果实现了__proc__成员函数，则调用该函数
        [函数形式定义的对象] 默认有__proc__成员函数：
            A() {...}   <==>   var A = {__name__:"A",__proc___:(){...}}
            
        如果对象没有实现__proc__，那么调用就是获取或者设置成员函数：
            A = {m:...}
            var a = A()

```
    A {
        __attr__: [
            a, b, get c, set d
        ],
        __init__: (n) {
            a = n;
            b = 'abc';
            get c = () {
                b + '[' + a + ']';
            };
        },
        __proc___: (m) {
            
        }
    }
    B(n) : A {
        this.a = n;
    }
    C(m, n) {
        this.b = m;
    }
    var a = A();
    var b = B();
    var c = C();
```


2) 如何创建对象
    
    相当于：
```
    A = {
        __func__ : (m ,n) {...},
        __attr__ : {
            a : number,
            b : string,
            c : function
        }
    }
```
    A是一个函数，使用this添加属性，this代表调用函数后构造的对象
    var a = A();

3) 如何表达类和对象
    类只是预置模型、初次结构的表达
    还说维持通用化的理论：万物皆对象
    但是外部只能看到对象的提供的服务(接口)

4) 如何表达对象的操作
    还是统一为发消息：外部解析服务后，服务接口组装消息并发送给对象，对象作为消息处理的实体而存在

