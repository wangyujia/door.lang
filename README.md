# door.lang
DOOR(分布式对象操作)语言
The Language Of Door (Distributed Object Operating Routine)


## Language Purpose
door-lang的首字母刚好组成中文的“门”，意为分布式组件之间提供连接的“门”。
door-lang是一种多范式编程语言，支持面向对象范式，也支持函数式编程，目的是把二者结合在一起。
目的是实现一种更适合用于粘合C/C++等可编译为机器指令的胶水语言（动态语言），同时语言具有灵活小巧的特性和范式，比如函数式语言，典型代表为js。
但是js嵌入到C/C++中，不太适合使用C/C++的native代码作为扩展。需要更加支持虚函数行为来定义对象的动态语言（getter/setter/...)
同时，把类型/对象/函数/参数等信息动态化 ……
另外，可支持编译为虚拟化的指令(bytescode字节码)或者本地机器码，字节码由VM解释执行（可加入AOT/JIT）……


## Language Features
为了更好的支持动态更新指令(bytescode字节码)的片段，需要把函数定义得更为小巧和灵活，所以预备以块为单位（类似于一般语言的lambda或者oc的block）。块就等同于函数体，同时不同参数的变体可以相似变形为：type、function、object。
```
/// ----------------------------------------------
/// door语言: {} -> type | function | object
    A {}                    ->      {__type__:"type",__name__:"A",__attr__:{}}
    A () {}                 ->      {__type__:"function", __name:"A",__proc__:{}}
    var a = {}              ->      {__type__:"object"}
    var a = () {}           ->      {__type__:"function", __proc__:{}}
    var a = new A();        ->      {__type__:"A"}.A();
    var b = new a();        ->      {__type__:"A"}.A();
    var c = a.m;            ->      ('m' in a)? (a.m) : (a(m));
    a.m = 1;                ->      ('m' in a)? (a.m = 1) : (a(m, 1));
/// ----------------------------------------------


/// ----------------------------------------------
/// [类型] 用于描述对象的组成：(类似c++/java中的类的定义方式)
    A {
        static a = 100;             // 定义类型的静态变量
        static b = 'ABC';
        number a;                   // 属性名称: "类型名称/函数名称/对象名称"作为限定
        string b;
        c {
            m1 = true;              // 也可以直接用"[],{},或者直接赋初值"
        }
        const d = 123;
        __init__(n) {               // __init__用来声明构造函数
            this.a = n;             // this代表创建的对象
            this.b = 'abc';
        }
    }                       ->      {__type__:"type",__name__:"A",__attr__:{a:"number",b:"string",c:"object","c.m1":"bool"}}
/// [类型 - 创建对象] 用new来创建对象：(无论写不写参数，如果类型定义了__init__函数，则尽量调用该函数)
    var a = new A;          ->      {__type__:"A",a:null,b:‘abc'}
    var a = new A(1);       ->      {__type__:"A",a:1,b:'abc'}
/// [类型 - 静态变量] 定义类型静态变量必须定义在__static__里面
/// ----------------------------------------------
/// [函数 - 普通] 用于实现普通功能：
/// A() {
        printlog('abc');
    }
/// [函数 - 设置对象] 使用this设置对象成员：
    A() {
        this.a = 1;
        this.b = 'abc';
    }
/// [函数 - 成员函数] 使用this设置对象成员：
    {
        f1() {
            this.a = 1;
            this.b = 'abc';
        },
        f2: () {
            this.a = 2;
            this.b = 'efg';
        }
    }
/// [函数 - 创建对象] 用new来创建对象：(这里必须携带参数)
    var a = new A();
/// ----------------------------------------------
/// [对象] 除了使用new来创建对象外，还可以：
```


1）如何把类的信息动态化
    首先给类唯一名称，然后同创建类的创建函数关联起来。
    框架：使用工厂管理[类唯一名称:类创建函数]
    语言：所有一切既是对象又是函数
        一个对象能被调用，如果实现了__proc__成员函数，则调用该函数
        [函数形式定义的对象] 默认有__proc__成员函数：
            A() {...}   <==>   var A = {__name__:"A",__proc___:(){...}}
            
        如果对象没有实现__proc__，那么调用就是获取或者设置成员函数：
            A = {m:...}
            var a = A()

```
    A {
        __attr__: [
            a, b, get c, set d
        ],
        __init__: (n) {
            a = n;
            b = 'abc';
            get c = () {
                b + '[' + a + ']';
            };
        },
        __proc___: (m) {
            
        }
    }
    B(n) : A {
        this.a = n;
    }
    C(m, n) {
        this.b = m;
    }
    var a = A();
    var b = B();
    var c = C();
```


2) 如何创建对象
    
    相当于：
```
    A = {
        __func__ : (m ,n) {...},
        __attr__ : {
            a : number,
            b : string,
            c : function
        }
    }
```
    A是一个函数，使用this添加属性，this代表调用函数后构造的对象
    var a = A();

3) 如何表达类和对象
    类只是预置模型、初次结构的表达
    还说维持通用化的理论：万物皆对象
    但是外部只能看到对象的提供的服务(接口)

4) 如何表达对象的操作
    还是统一为发消息：外部解析服务后，服务接口组装消息并发送给对象，对象作为消息处理的实体而存在

